
Variablen, Ausdrücke und Anweisungen
====================================

Werte und Datentypen
--------------------

\index{Wert}
\index{Datentyp}
\index{Zeichenkette}

Ein *Wert* ist eines der grundlegenden Elemente, mit denen ein Programm arbeitet, wie ein Buchstabe oder eine Zahl. Die Werte, die wir bis jetzt gesehen haben, sind `1`, `2` und `'Hallo, Welt!'`.

Diese Werte gehören zu unterschiedlichen *Datentypen*: `2` ist eine Ganzzahl, und `'Hello, World!'` ist eine Zeichenkette (englisch *String*), so genannt, weil sie eine „Kette“ von Buchstaben enthält. Wir (und der Python-Interpreter) können Zeichenketten erkennen, weil sie in Anführungszeichen eingeschlossen sind.

\index{Anführungszeichen}

Die Anweisung `print` funktioniert auch für Ganzzahlen. Wir verwenden den Befehl `python`, um den Interpreter zu starten.

~~~~ {.python}
python
>>> print(4)
4
~~~~

Wenn man nicht sicher sind, welchen Typ ein Wert hat, kann der Interpreter es einem sagen.

~~~~ {.python .trinket height="160"}
>>> type('Hello, World!')
<class 'str'>
>>> type(17)
<class 'int'>
~~~~

Es überrascht nicht, dass Zeichenketten zum Typ `str` und Ganzzahlen zum Typ `int` gehören. Weniger offensichtlich gehören Zahlen mit einem Dezimalpunkt zu einem Typ namens `float`, da diese Zahlen in einem Format namens *Fließkomma* (oder *Gleitkommazahl*, englisch floating point number) dargestellt werden.

\index{Datentyp}
\index{Zeichenkette}
\index{Klasse!str}
\index{Ganzzahl}
\index{Klasse!int}
\index{Gleitkommazahl}
\index{Klasse!float}

~~~~ {.python .trinket height="120"}
>>> type(3.2)
<class 'float'>
~~~~

Was ist mit Werten wie `17` und `3.2`? Sie sehen aus wie Zahlen, stehen aber in Anführungszeichen wie Zeichenketten.

\index{Anführungszeichen}

~~~~ {.python .trinket  height="160"}
>>> type('17')
<class 'str'>
>>> type('3.2')
<class 'str'>
~~~~

Es sind Zeichenketten.

Wenn man eine große Ganzzahl eingeben, könnte man versucht sein, Kommata zwischen Gruppen von drei Ziffern zu verwenden, wie in `1,000,000`. Dies ist in Python keine gültige Ganzzahl, die Anweisung selbst ist jedoch zulässig:

~~~~ {.python .trinket height="120"}
>>> print(1,000,000)
1 0 0
~~~~

Nun, das ist überhaupt nicht das, was wir erwartet haben! Python interpretiert `1,000,000` als eine durch Kommata getrennte Folge von ganzen Zahlen, die es mit Leerzeichen dazwischen ausgibt.

\index{semantischer Fehler}
\index{Fehler!semantischer}
\index{Fehlermeldung}

Dies ist das erste Beispiel eines *semantischen Fehlers*, den wir gesehen haben: Der Code wird ohne eine Fehlermeldung zu erzeugen ausgeführt, aber er tut nicht das „Richtige“.

Variablen
---------

\index{Variable}
\index{Zuweisung}
\index{Anweisung!Zuweisung}

Eine der mächtigsten Eigenschaften einer Programmiersprache ist die Fähigkeit, *Variablen* zu manipulieren. Eine Variable ist ein Bezeichner, der sich auf einen Wert bezieht.

Eine *Zuweisung* erzeugt neue Variablen und gibt ihnen Werte:

~~~~ {.python}
>>> message = 'And now for something completely different'
>>> n = 17
>>> pi = 3.1415926535897931
~~~~

In diesem Beispiel werden drei Zuweisungen vorgenommen. Die erste weist eine Zeichenkette einer neuen Variablen namens `message` zu; die zweite weist die ganze Zahl `17` der Variablen `n` zu; die dritte weist den (ungefähren) Wert von $\pi$ `pi` zu.

Um den Wert einer Variablen anzuzeigen, können Sie eine Print-Anweisung verwenden:

~~~~ {.python}
>>> print(n)
17
>>> print(pi)
3.141592653589793
~~~~

Der Typ einer Variablen ist der Typ des Wertes, auf den sie sich bezieht.

~~~~ {.python}
>>> type(message)
<class 'str'>
>>> type(n)
<class 'int'>
>>> type(pi)
<class 'float'>
~~~~

Variablennamen und Schlüsselwörter
----------------------------------

\index{Schlüsselwort}

Programmierer wählen für ihre Variablen in der Regel Namen, die aussagekräftig sind und dokumentieren, wofür die Variable verwendet wird.

Variablennamen können beliebig lang sein. Sie können sowohl Buchstaben als auch Zahlen enthalten, aber sie dürfen nicht mit einer Zahl beginnen. Es ist erlaubt, Großbuchstaben zu verwenden, aber es ist eine gute Idee, Variablennamen mit einem Kleinbuchstaben zu beginnen (Wir werden später sehen, warum).

Das Unterstrich (`\_`) kann in einem Variablennamen vorkommen. Es wird häufig in Variablen mit mehreren Wörtern verwendet, z. B. `my_name` oder `airspeed_of_light`. Variablennamen können mit einem Unterstrich beginnen, aber wir vermeiden dies im Allgemeinen, es sei denn, wir schreiben Bibliothekscode, den andere verwenden sollen.

\index{Unterstrich}

Wenn wir einer Variablen einen unzulässigen Namen geben, erhalten wir einen Syntaxfehler:

~~~~ {.python .trinket height="450"}
>>> 76trombones = 'big parade'
SyntaxError: invalid syntax
>>> more@ = 1000000
SyntaxError: invalid syntax
>>> class = 'Advanced Theoretical Zymurgy'
SyntaxError: invalid syntax
~~~~

Der Variablenname `76trombones` ist unzulässig, weil er mit einer Zahl beginnt. `more@` ist unzulässig, weil es ein unerlaubtes Zeichen (`@`) enthält. Aber was ist falsch an `class`?

Es stellt sich heraus, dass `class` eines von Pythons *Schlüsselwörtern* (englisch *Keyword*) ist. Der Interpreter verwendet Schlüsselwörter, um die Struktur des Programms zu erkennen, und sie können nicht als Variablennamen verwendet werden.

\index{Schlüsselwort}

Python reserviert 35 Schlüsselwörter:

~~~~
and       del       from      None      True
as        elif      global    nonlocal  try
assert    else      if        not       while
break     except    import    or        with
class     False     in        pass      yield
continue  finally   is        raise     async
def       for       lambda    return    await
~~~~

Man sollte diese Liste griffbereit halten. Wenn sich der Interpreter über einen der Variablennamen beschwert und wir nicht wissen, warum, sehen wir nach, ob er auf dieser Liste steht.

Anweisungen
-----------

Eine *Anweisung* ist eine Einheit von Code, die der Python-Interpreter ausführen kann. Wir haben zwei Arten von Anweisungen gesehen: Ausdrücke wie `print(n)` und Zuweisungen wie `n = 17`.

\index{Anweisung}
\index{interaktiver Modus}
\index{Skriptmodus}

Wenn wir eine Anweisung im interaktiven Modus eingeben, führt der Interpreter sie aus und zeigt das Ergebnis an, falls es eines gibt.

Ein Skript enthält normalerweise eine Folge von Anweisungen. Wenn es mehr als eine Anweisung gibt, erscheinen die Ergebnisse nacheinander, während die Anweisungen ausgeführt werden.

Zum Beispiel erzeugt das Skript

~~~~ {.python}
print(1)
x = 2
print(x)
~~~~

folgende Ausgabe:

~~~~
1
2
~~~~

Die Zuweisung erzeugt keine Ausgabe.

Operatoren und Operanden
------------------------

\index{Operator!arithmetisch}
\index{arithmetischer Operator}
\index{Operand}
\index{Ausdruck}

*Operatoren* sind spezielle Symbole, die Berechnungen wie Addition und Multiplikation darstellen. Die Werte, auf die der Operator angewendet wird, werden *Operanden* genannt.

Die Operatoren `+`, `-`, `*`, `/` und `**` führen Addition, Subtraktion, Multiplikation, Division und Potenzierung aus, wie in den folgenden Beispielen:

~~~~ {.python}
20+32
hour-1
hour*60+minute
minute/60
5**2
(5+9)*(15-7)
~~~~

Zwischen Python 2.x und Python 3.x hat sich der Divisionsoperator geändert. In Python 3.x ist das Ergebnis dieser Division eine Fließkommazahl:

~~~~ {.python .trinket height="160"}
>>> minute = 59
>>> minute/60
0.9833333333333333
~~~~

Der Divisionsoperator in Python 2.0 würde zwei Ganzzahlen dividieren und als Ergebnis den Anteil vor dem Komma verwenden:

~~~~ {.python}
>>> minute = 59
>>> minute/60
0
~~~~

Um das gleiche Ergebnis in Python 3.0 zu erhalten, verwenden wir die ganzzahlige Division (`//` Ganzzahl).

~~~~ {.python .trinket  height="160"}
>>> minute = 59
>>> minute//60
0
~~~~

In Python 3.0 funktioniert die ganzzahlige Division also eher so, wie wir es erwarten würden, wenn wir den Ausdruck in einen Taschenrechner eingeben würden.

\index{Python 3.0}
\index{Python 2.0}
\index{Fließkommadivision}
\index{Division!Fließkomma}

Ausdrücke
---------

Ein *Ausdruck* ist eine Kombination aus Werten, Variablen und Operatoren. Ein Wert allein wird als Ausdruck betrachtet, ebenso wie eine Variable, so dass die folgenden Ausdrücke alle zulässig sind (unter der Annahme, dass der Variablen `x` ein Wert zugewiesen wurde):

\index{Ausdruck}
\index{Auswertung}

~~~~ {.python}
17
x
x + 17
~~~~

Wenn wir einen Ausdruck im interaktiven Modus eingeben, wird er vom Interpreter *ausgewertet* und das Ergebnis angezeigt:

~~~~ {.python}
>>> 1 + 1
2
~~~~

Aber in einem Skript bewirkt ein Ausdruck für sich allein gar nichts! Dies ist eine häufige Ursache für Verwirrung bei Programmieranfängern.

**Übung 1: Geben Sie die folgenden Anweisungen in den Python-Interpreter ein, um zu sehen, was sie bewirken:**

~~~~ {.python}
5
x = 5
x + 1
~~~~

Reihenfolge der Auswertung
--------------------------

\index{Auswertungsreihenfolge}
\index{Vorrangregeln}
\index{PEMDAS}

Wenn mehr als ein Operator in einem Ausdruck vorkommt, hängt die Reihenfolge der Auswertung von den *Vorrangregeln* ab. Für mathematische Operatoren folgt Python der mathematischen Konvention. Das Akronym *PEMDAS* ist eine nützliche Methode, um sich die Regeln zu merken:

\index{Klammern!Vorrangregeln überschreiben}

-   *P*arentheses (Klammern) haben den höchsten Vorrang und können verwendet werden, um die Auswertung eines Ausdrucks in der gewünschten Reihenfolge zu erzwingen. Da Ausdrücke in Klammern zuerst ausgewertet werden, ist `2 * (3-1)` gleich 4 und `(1+1)**(5-2)` gleich 8. Wir können Klammern auch verwenden, um einen Ausdruck leichter lesbar zu machen, wie in `(Minute * 100) / 60`, auch wenn dies das Ergebnis nicht ändert.

-   *E*xponentiation (Potenzierung) hat die nächsthöhere Priorität, also ist `2**1+1` gleich 3, nicht 4, und `3*1**3` ist 3, nicht 27.

-   *M*ultiplikation und *D*ivision haben den gleichen Vorrang, der höher ist als der von *A*ddition und *S*ubtraktion, die ebenfalls den gleichen Vorrang haben. Also ist `2*3-1` 5, nicht 4, und `6+4/2` ist 8, nicht 5.

-   Operatoren mit der gleichen Rangfolge werden von links nach rechts ausgewertet. Der Ausdruck `5-3-1` ist also 1, nicht 3, weil zuerst `5-3` ausgeführt wird und dann `1` von 2 subtrahiert wird.

Wir müssen im Zweifelsfall immer Klammern in unsere Ausdrücke setzen, um sicherzustellen, dass die Berechnungen in der von uns beabsichtigten Reihenfolge durchgeführt werden.

Division mit Rest
-----------------

\index{Modulo (Operator)}
\index{Operator!Modulo}

Der *Modulo-Operator* arbeitet mit ganzen Zahlen und liefert den Rest, wenn der erste Operand durch den zweiten geteilt wird. In Python ist der Modulo-Operator ein Prozentzeichen (`%`). Die Syntax ist die gleiche wie bei den anderen Operatoren:

~~~~ {.python .trinket height="240"}
>>> quotient = 7 // 3
>>> print(quotient)
2
>>> remainder = 7 % 3
>>> print(remainder)
1
~~~~

Also 7 geteilt durch 3 ist 2 und der Rest 1 bleibt.

Der Modulo-Operator erweist sich als erstaunlich nützlich. Man kann zum Beispiel prüfen, ob eine Zahl durch eine andere teilbar ist: Wenn `x % y` Null ist, dann ist `x` durch `y` teilbar.

\index{Teilbarkeit}

Man kann auch die äußerste rechte Stelle einer Zahl extrahieren. Zum Beispiel ergibt `x % 10` die äußerste rechte Ziffer von `x` (zur Basis 10). In gleicher Weise ergibt `x % 100` die letzten beiden Ziffern.

Operationen mit Zeichenketten
-----------------------------

\index{Zeichenkette!Operation}
\index{Operator!Zeichenkette}

Der Operator `+` arbeitet mit Zeichenketten, aber es ist keine Addition im mathematischen Sinne. Stattdessen führt er eine *Konkatenation* (Verkettung) durch, d. h. er verbindet die Zeichenketten, indem er sie Ende an Ende verknüpft. Zum Beispiel:

\index{Konkatenation}

~~~~ {.python}
>>> first = 10
>>> second = 15
>>> print(first+second)
25
>>> first = '100'
>>> second = '150'
>>> print(first + second)
100150
~~~~

Der Operator `*` arbeitet auch mit Zeichenketten, indem er den Inhalt einer Zeichenkette mithilfe einer ganzen Zahl vervielfältigt. Zum Beispiel:

~~~~ {.python}
>>> first = 'Test '
>>> second = 3
>>> print(first * second)
Test Test Test
~~~~

Benutzereingaben
----------------

\index{Benutzereingaben}

Manchmal möchten wir den Wert für eine Variable über eine Tastatureingabe einlesen. Python bietet eine eingebaute Funktion namens `input`, die Eingaben von der Tastatur entgegennimmt^[In Python 2.0 hieß diese Funktion `raw_input`.] Wenn diese Funktion aufgerufen wird, hält das Programm an und wartet darauf, dass der Benutzer etwas eingibt. Wenn der Benutzer die Enter-Taste drückt, wird das Programm fortgesetzt und `input` gibt zurück, was der Benutzer als Zeichenkette getippt hat.

\index{Python 2.0}

~~~~ {.python}
>>> inp = input()
Some silly stuff
>>> print(inp)
Some silly stuff
~~~~

Bevor man eine Eingabe vom Benutzer erhält, ist es eine gute Idee, eine Eingabeaufforderung (Prompt) auszugeben, die dem Benutzer mitteilt, was er eingeben soll. Man kann eine Zeichenkette an `input` übergeben, die dem Benutzer angezeigt wird, bevor er zur Eingabe aufgefordert wird:

\index{Prompt}

~~~~ {.python}
>>> name = input('What is your name?\n')
What is your name?
Chuck
>>> print(name)
Chuck
~~~~

Die Sequenz `\n` am Ende des Prompt stellt ein *Newline* dar, ein Sonderzeichen, das einen Zeilenumbruch bewirkt. Deshalb erscheint die Eingabe des Benutzers unterhalb des Prompts.

\index{Newline}

Wenn man erwartet, dass der Benutzer eine Ganzzahl eingibt, können wir versuchen, den Rückgabewert mit der Funktion `int()` in `int` umzuwandeln:

~~~~ {.python}
>>> prompt = 'What...is the airspeed velocity of an unladen swallow?\n'
>>> speed = input(prompt)
What...is the airspeed velocity of an unladen swallow?
17
>>> int(speed)
17
>>> int(speed) + 5
22
~~~~

Wenn der Benutzer jedoch etwas anderes als eine Ziffernfolge eingibt, erhalten wir einen Fehler:

~~~~ {.python}
>>> speed = input(prompt)
What...is the airspeed velocity of an unladen swallow?
What do you mean, an African or a European swallow?
>>> int(speed)
ValueError: invalid literal for int() with base 10:
~~~~

Wir werden später sehen, wie diese Art von Fehler zu behandeln ist.

\index{ValueError}
\index{Ausnahme!ValueError}

Kommentare
----------

\index{Kommentar}

Je größer und komplizierter Programme werden, desto schwieriger werden sie zu lesen. Formale Sprachen sind komplex, und es ist oft schwierig, einen Teil des Codes zu betrachten und herauszufinden, was er tut oder warum.

Aus diesem Grund ist es eine gute Idee, Notizen zu unseren Programmen hinzuzufügen, um in natürlicher Sprache zu erklären, was das Programm tut. Diese Notizen werden *Kommentare* genannt, und in Python beginnen sie mit dem Symbol `#`:

~~~~ {.python}
# compute the percentage of the hour that has elapsed
percentage = (minute * 100) / 60
~~~~

In diesem Fall erscheint der Kommentar in einer eigenen Zeile. Wir können Kommentare auch als Zeilenendkommentar an das Ende einer Zeile setzen:

~~~~ {.python}
percentage = (minute * 100) / 60     # percentage of an hour
~~~~

Alles vom `#` bis zum Ende der Zeile wird ignoriert; es hat keine Auswirkung auf das Programm.

Kommentare sind am nützlichsten, wenn sie nicht offensichtliche Merkmale des Codes dokumentieren. Es ist vernünftig anzunehmen, dass der Leser herausfinden kann, *was* der Code tut; es ist viel nützlicher, zu erklären *warum*.

Dieser Kommentar ist im Zusammenhang mit dem Code redundant und nutzlos:

~~~~ {.python}
v = 5     # assign 5 to v
~~~~

Dieser Kommentar dagegen enthält nützliche Informationen, die nicht im Code enthalten sind:

~~~~ {.python}
v = 5     # velocity in meters/second.
~~~~

Gute Variablennamen können die Notwendigkeit von Kommentaren reduzieren, aber zu lange Namen können komplexe Ausdrücke schwer lesbar machen. Daher sollten geeignete Variablennamen gewählt werden.

Wählen sprechender Variablennamen
---------------------------------

Solange wir die einfachen Regeln für die Benennung von Variablen befolgen und reservierte Wörter vermeiden, haben wir bei der Benennung unserer Variablen einen großen Spielraum. Am Anfang kann diese Auswahl verwirrend sein, sowohl wenn wir ein Programm lesen als auch wenn wir unsere eigenen Programme schreiben. Die folgenden drei Programme sind zum Beispiel identisch in Bezug auf das, was wir leisten, aber sehr unterschiedlich, wenn wir sie lesen und versuchen, sie zu verstehen.

~~~~ {.python}
a = 35.0
b = 12.50
c = a * b
print(c)
~~~~

~~~~ {.python}
hours = 35.0
rate = 12.50
pay = hours * rate
print(pay)
~~~~

~~~~ {.python}
x1q3z9ahd = 35.0
x1q3z9afd = 12.50
x1q3p9afd = x1q3z9ahd * x1q3z9afd
print(x1q3p9afd)
~~~~

Der Python-Interpreter interpretiert alle drei Programme als *gleichwertig*, aber Menschen sehen und verstehen diese Programme ganz anders. Menschen werden die *Intention* des zweiten Programms am schnellsten verstehen, weil der Programmierer Variablennamen gewählt hat, die seine Absicht bezüglich der Daten, die in jeder Variablen gespeichert werden, widerspiegeln.

Wir nennen diese sinnvoll gewählten Variablennamen „sprechende“ Variablennamen.

Obwohl das alles toll klingt und es eine sehr gute Idee ist, sprechende Variablennamen zu verwenden, können sprechende Variablennamen den Programmieranfänger bei der Analyse von Code verwirren. Das liegt daran, dass sich Programmieranfänger die reservierten Schlüsselwörter noch nicht eingeprägt haben (es gibt nur 33 davon). So kann es vorkommen, das ein Anfänger einen sprechenden Variablennamen fälschlicherweise als Teil der Programmiersprache auffasst.

Werfen wir einen kurzen Blick auf den folgenden Python-Beispielcode, der mithilfe einer Schleife durch einen Datensatz iteriert. Wir werden Schleifen bald behandeln, aber versuchen wir jetzt erst einmal, uns vorzustellen, was hier passiert:

~~~~ {.python}
for word in words:
    print(word)
~~~~

Was ist hier los? Welche der Token (for, word, in, etc.) sind reservierte Wörter und welche sind nur Variablennamen? Versteht Python auf einer fundamentalen Ebene den Begriff der Wörter? Programmieranfänger haben Schwierigkeiten zu unterscheiden, welche Teile des Codes so sein *müssen* wie sie es sind und welche Teile des Codes freie Entscheidungen des Programmierers sind.

Der folgende Code ist äquivalent zum obigen Code:

~~~~ {.python}
for slice in pizza:
    print(slice)
~~~~

Für den Programmieranfänger ist es einfacher, sich diesen Code anzusehen und zu wissen, welche Teile reservierte Wörter sind, die von Python definiert wurden, und welche Teile einfach vom Programmierer gewählte Variablennamen sind. Es ist ziemlich klar, dass Python kein grundlegendes Verständnis von Pizza und Pizzastücken hat und der Tatsache, dass eine Pizza aus einer Menge von einer oder mehreren Pizzastücken besteht.

Aber wenn es in unserem Programm wirklich darum geht, Daten zu lesen und nach Wörtern in den Daten zu suchen, sind `pizza` und `slice` wenig sprechende Variablennamen. Sie als Variablennamen zu wählen, lenkt vom Sinn des Programms ab.

Nach recht kurzer Zeit wird man die häufigsten reservierten Wörter kennen, und man wird anfangen, die reservierten Wörter zu sehen, die einem entgegenspringen:

<pre>
<b>for</b> word <b>in</b> words<b>:</b>
    <b>print</b>(word)
</pre>

Die Teile des Codes, die von Python definiert sind (`for`, `in`, `print` und `:`), sind fett gedruckt, die vom Programmierer gewählten Variablen (`word` und `words`) sind nicht fett gedruckt. Viele Texteditoren sind sich der Python-Syntax bewusst und färben reservierte Wörter anders ein, um Hinweise zu geben, die Variablen und reservierten Wörter getrennt zu halten. Nach einer Weile wird man anfangen, Python zu lesen und schnell feststellen, was eine Variable und was ein reserviertes Wort ist.

Debugging
---------

\index{Debugging}

An dieser Stelle ist der Syntaxfehler, den wir am ehesten machen, ein illegaler Variablenname, wie `class` und `yield`, die Schlüsselwörter sind, oder `odd~job` und `US$`, die unzulässige Zeichen enthalten.

\index{Syntaxfehler}
\index{Fehler!syntax}

Wenn wir ein Leerzeichen in einen Variablennamen setzen, denkt Python, dass es sich um zwei Operanden ohne einen Operator handelt:

~~~~ {.python}
>>> bad name = 5
SyntaxError: invalid syntax
~~~~

~~~~ {.python}
>>> month = 09
  File "<stdin>", line 1
    month = 09
             ^
SyntaxError: invalid token
~~~~

Bei Syntaxfehlern sind die Fehlermeldungen nicht sehr hilfreich. Die häufigsten Meldungen sind `SyntaxError: invalid syntax` und `SyntaxError: invalid token`, die beide nicht sehr informativ sind.

\index{Fehlermeldung}
\index{use before def}
\index{Ausnahme}
\index{Laufzeitfehler}
\index{Fehler!Laufzeit}

Der Laufzeitfehler, den wir am ehesten machen, ist ein „use before definition“, d. h. der Versuch, eine Variable zu verwenden, bevor man einen Wert zugewiesen hat. Dies kann passieren, wenn man einen Variablennamen falsch schreiben:

~~~~ {.python}
>>> principal = 327.68
>>> interest = principle * rate
NameError: name 'principle' is not defined
~~~~

Bei Variablennamen wird zwischen Groß- und Kleinschreibung unterschieden (englisch *case-sensitivity*), daher ist `LaTeX` nicht dasselbe wie `latex`.

\index{case-sensitivity, Variablennamen}
\index{semantischer Fehler}
\index{Fehler!semantischer}

An diesem Punkt ist die wahrscheinlichste Ursache für einen semantischen Fehler die Reihenfolge der Operationen. Um z. B. $1/2\pi$ auszuwerten, könnte man versucht sein, zu schreiben

~~~~ {.python}
>>> 1.0 / 2.0 * pi
~~~~

aber die Division geschieht zuerst, also würden wir $\pi / 2$ erhalten, was nicht dasselbe ist! Es gibt keine Möglichkeit für Python zu wissen, was wir eigentlich schreiben wollten, also bekommen wir in diesem Fall keine Fehlermeldung; Wir bekommen einfach die falsche Antwort.

\index{Auswertungsreihenfolge}

Glossar
-------

Zuweisung
:   Eine Anweisung, die einer Variablen einen Wert zuweist.
\index{Zuweisung}

konkatenieren
:   Verkettung zweier Operanden.
\index{Konkatenation}

Kommentar
:   Informationen in einem Programm, die für andere Programmierer (oder jeden, der den Quellcode liest) bestimmt sind und keinen Einfluss auf die Ausführung des Programms haben.
\index{Kommentar}

auswerten
:   Einen Ausdruck vereinfachen, indem die Operationen so ausgeführt werden, dass ein einziger Wert entsteht.
\index{Auswertung}

Ausdruck
:   Eine Kombination aus Variablen, Operatoren und Werten, die einen einzelnen Ergebniswert darstellt.
\index{Ausdruck}

Gleitkommazahl
:   Ein Datentyp, der Zahlen mit Nachkommastellen darstellt.
\index{Gleitkommazahl}

Ganzzahl
:   Ein Datentyp, der ganze Zahlen darstellt.
\index{Ganzzahl}

Schlüsselwort
:   Ein reserviertes Wort, das vom Compiler verwendet wird, um ein Programm zu analysieren; Man kann Schlüsselwörter wie `if`, `def` und `while` nicht als Variablennamen verwenden.
\index{Schlüsselwort}

Modulo-Operator
:   Ein Operator, der mit einem Prozentzeichen (`%`) gekennzeichnet ist, der mit ganzen Zahlen arbeitet und den Rest ergibt, wenn eine Zahl durch eine andere dividiert wird.
\index{Modulo (Operator)}
\index{Operator!Modulo}

Operand
:   Einer der Werte, mit dem ein Operator arbeitet.
\index{Operand}

Operator
:   Ein spezielles Symbol, das eine einfache Berechnung wie Addition, Multiplikation oder String-Verkettung darstellt.
\index{Operator}

Vorrangregeln
:   Die Reihenfolge, in der Ausdrücke mit mehreren Operatoren und Operanden ausgewertet werden.
\index{Vorrangregeln}
\index{Vorrang}

Anweisung
:   Ein Abschnitt des Codes, der einen Befehl oder eine Aktion darstellt. Die Anweisungen, die wir bisher gesehen haben, sind Zuweisungen und Ausgabe-Anweisungen.
\index{Anweisung}

Zeichenkette
:   Ein Datentyp, der Zeichenfolgen (englisch *string*) repräsentiert.
\index{Zeichenkette}

Datentyp
:   Eine Kategorie von Werten. Die Typen, die wir bisher gesehen haben, sind Ganzzahlen (Typ `int`), Gleitkommazahlen (Typ `float`) und Zeichenketten (Typ `str`).
\index{Datentyp}

Wert
:   Eine der grundlegenden Dateneinheiten, wie z. B. eine Zahl oder eine Zeichenkette, die von einem Programm manipuliert wird.
\index{Wert}

Variable
:   Ein Bezeichner, der sich auf einen Wert bezieht.
\index{Variable}

Übungen
-------

**Übung 2: Schreiben Sie ein Programm, das mit `input` einen Benutzer zur Eingabe seines Namens auffordert und ihn dann begrüßt.**

~~~~
Enter your name: Chuck
Hello Chuck
~~~~

**Übung 3: Schreiben Sie ein Programm, das den Benutzer nach Arbeitsstunden und Stundensatz fragt, um den Bruttolohn zu berechnen.**

~~~~
Enter Hours: 35
Enter Rate: 2.75
Pay: 96.25
~~~~

Wir werden uns erst einmal nicht darum kümmern, dass unsere Auszahlung genau zwei Stellen nach dem Komma hat. Wenn Sie möchten, können Sie mit der eingebauten Python-Funktion `round` experimentieren, um den resultierenden Lohn auf zwei Dezimalstellen zu runden.

**Übung 4: Angenommen, wir führen die folgenden Zuweisung aus:**

~~~~
width = 17
height = 12.0
~~~~

Schreiben Sie für jeden der folgenden Ausdrücke den Wert des Ausdrucks und den Datentyp (des Wertes des Ausdrucks).

1.  `width//2`

2.  `width/2.0`

3.  `height/3`

4.  `1 + 2 * 5`

Verwenden Sie den Python-Interpreter, um Ihre Antworten zu überprüfen.

**Übung 5: Schreiben Sie ein Programm, das den Benutzer zur Eingabe einer Celsius-Temperatur auffordert, die Temperatur in Fahrenheit konvertiert und die konvertierte Temperatur ausgibt.**

